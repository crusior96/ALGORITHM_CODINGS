//n*n의 판에 왼쪽 맨 위에서 오른쪽 맨 아래에 도착하는 파이프를 설치하려한다.
//최초의 파이프는 맨 왼쪽 위에서 가로 방향으로 뉘여져 있으며, 파이프는 가로(오른쪽방향), 세로(아랫방향), 대각선(우하단)으로만 설치할 수 있다.
//이때, 파이프를 설치하기위해선 파이프가 도착하는 부분이 벽으로 막혀있어선 안된다.
//판의 길이와 맵 상태를 입력받았을때, 파이프를 설치할 수 있는 방법의 수를 구한다.
//단, 파이프를 설치할 수 없을땐 0을 출력한다.

#include<cstdio>
#include<iostream>
int n, ans;
int a[16][16];
int dx[] = { 0, 1, 1 }, dy[] = { 1, 0, 1 };
//dx와 dy배열을 for문을 사용함으로서 파이프를 설치할 수 있는 세 가지 방법을 나타낸다.

void solve(int x, int y, int z) {
	//도착지점에 도착했을경우엔 하나의 경로를 적립해주며 ans+=1을 해준다
	if (x == n - 1 && y == n - 1) {
		ans += 1;
		return;
	}
	//i = 1 : 가로방향 파이프
	//i = 2 : 대각선방향 파이프
	//i = 3 : 세로방향 파이프
	for (int i = 0; i < 3; i++) {
		if (i + z == 1) 
			continue;
		int nx = x + dx[i], ny = y + dy[i];

		if (nx >= n || ny >= n || a[nx][ny]) 
			continue;
		//파이프의 도착지점이 판을 넘어서지 않으며 장애물이 없을경우

		if (i == 2 && (a[x][y + 1] || a[x + 1][y])) 
			continue;
		//대각선 파이프를 설치하려할때 파이프의 도착지점 주변에 장애물이 없을경우
		solve(nx, ny, i);
	}
}

int main() 
{
	scanf("%d", &n);

	for (int i = 0; i < n; i++) 
	{
		for (int j = 0; j < n; j++) 
		{
			//벽에의해 가로막혀지는 부분은 1, 빈 공간은 0으로 저장해준다.
			scanf("%d", &a[i][j]);
		}
	}

	solve(0, 1, 0);
	printf("%d\n", ans);
	return 0;

}
