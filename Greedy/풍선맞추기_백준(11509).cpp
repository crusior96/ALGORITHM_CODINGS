#include<iostream>
using namespace std;

int arr[1000001] = {};

//N개의 풍선들이 일렬로 놓여있다고 가정하자
//왼쪽부터 오른쪽으로 나열된 상태에서 왼쪽에서 다트를 던지고자 한다
//이때 다트가 풍선을 맞추면 현재 다트의 높이에서 -1 된 상태로 다트가 날아간다고 한다
//풍선들을 모두 터트린다면 그 때 다트를 던진 최소한의 횟수를 구하여라

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int N, temp;
	int answer = 0;
	cin >> N;
	//그리디 알고리즘을 사용한 문제풀이
	//이 방법에 익숙해져야하며 DP와 응용할 수 있는 접근법 중 하나이지만 단독으로도 많이쓰인다
	//풍선의 높이를 입력했을때, 만약 해당 풍선보다 1칸 위에서부터 날아오는 다트가 없다면
	//현재 위치에서 다트가 날아오므로 갯수를 1 증가시켜주고 답을 1 증가시킨다
	for (int i = 0;i < N;i++) {
		cin >> temp;
		if (arr[temp + 1] == 0) {
			arr[temp]++;
			answer++;
		}
		//만약 해당 풍선보다 1칸 위에서부터 날아오는 다트가 존재한다면
		//해당 높이에서 날아오는 다트의 갯수를 1 줄이고, 해당 높이에서 -1이 된 현재 높이에서 날아오는 다트의 갯수를 1 증가시킨다
		else {
			arr[temp + 1]--;
			arr[temp]++;
		}
	}

	cout << answer << '\n';
	return 0;
}

//해당 문제를 풀기 전에 다른 방식으로 문제를 풀어보긴 했다
//N개의 풍선에 대한 현재 높이 정보를 토대로 풍선 갯수들을 누적한 다음, 맨 왼쪽부터 오른쪽까지 해당 위치 풍선의 높이를 탐색한다
//현 위치의 풍선이 터지지 않은 채 존재한다면, 사실상 오른쪽 위치에 있는 풍선들의 정보는 arr에 있으니 높이를 1칸씩 내려가며 터트린다
//터트릴 풍선이 없다면 break문을 걸고 다음 풍선으로 넘어가는데 만약 다음 풍선이 존재하지 않는다면 또 넘기는 방식으로 진행한다
//어쩌면 반례가 있거나 내가 조건을 잘못 걸었을지도 모른다. 문제 해결을 위해 제 3자의 시선이 필요하다.