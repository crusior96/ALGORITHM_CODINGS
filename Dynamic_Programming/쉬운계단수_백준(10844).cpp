#include<iostream>
using namespace std;

//각 자리 사이사이의 차이가 1씩만 나는 수를 계단수라고 한다.
//이때, N자리의 자연수에서 찾을 수 있는 계단수의 갯수는 총 몇개인가?
//단, 출력되는 값은 (갯수%1000000000)이다.


int main()
{
	int N;
	unsigned long long int ways = 0; //계단수의 최종값
	int basic[105][10] = {};
	//DP를 사용하기 위해 초기값을 지정해준다.
	//이때, 왼쪽의 수를 기준으로 오른쪽 자릿수에 영향을 주기 때문에
	//맨 앞자리가 0인경우는 제외하기때문에 basic[1][1~9]의 부분에 1을 저장해준다.
	for (int i = 1;i < 10;i++)
	{
		basic[1][i] = 1;
	}
	cin >> N;
	//왼쪽 자릿수까지 도달하는 방법의 경우의 수를 오른쪽 자리에 계속 추가해주는 방식으로 DP를 진행한다.
	//왼쪽 자릿수의 값에따라 오른쪽자리로의 영향을 줄 수 있는 방법은 3가지로 나뉘어진다.
	//DP를 사용하는 과정중에 항상 1000000000으로 값을 나누어 나머지만 있게 한다.
	for (int i = 1;i <= N;i++)
	{
		for (int j = 0;j < 10;j++)
		{
			//1. 왼쪽 자리가 0일경우
			//오른쪽 자리가 1인 경우에만 영향을 받을 수 있다.
			if (j == 0)
			{
				basic[i + 1][1] = (basic[i + 1][1] + basic[i][0]) % 1000000000;
			}
			//2. 왼쪽 자리가 9인경우
			//오른쪽 자리가 8인 경우에만 영향을 받을 수 있다.
			else if (j == 9)
			{
				basic[i + 1][8] = (basic[i + 1][8] + basic[i][9]) % 1000000000;
			}
			//3. 그 외의 경우
			//왼쪽 자리를 기준으로 1보다 크거나 작은 경우에만 영향을 받을 수 있다.
			else
			{
				basic[i + 1][j + 1] = (basic[i + 1][j + 1] + basic[i][j]) % 1000000000;
				basic[i + 1][j - 1] = (basic[i][j] + basic[i + 1][j - 1]) % 1000000000;
			}
		}
	}

	//맨 끝자리까지 도달하여 그 값들이 저장된 basic[N][0~9]에 있는 값들을
	//ways에 더하면서 1000000000으로 나누어준다.
	for (int i = 0;i <= 9;i++)
	{
		ways = (ways + basic[N][i]) % 1000000000;
	}
	ways %= 1000000000;
	cout << ways << endl;
	return 0;
}
