#include<iostream>
using namespace std;

//붕어빵 N개를 판매하는 K군은 어떻게 해야 제일 비싸게 팔 수 있는지를 고민하고 있다.
//1 ~ N개짜리 세트로 판매하고 있으며 각각의 가격은 서로 다르다.
//각각의 세트를 조합해서 제일 비싼 가격을 얻고자 하면 얼마를 벌 수 있을까?

int main()
{
	int boong[1002] = {};
	int price[1002] = {};
	int N;
	cin >> N;
	//붕어빵이 1개에서 N개의 셋트구성으로 판매할 수 있을때, 그때의 가격들을 price와 boong에 동일하게 저장해둔다.
	//boong은 누적되는 붕어빵 판매액의 저장소이다.
	for (int i = 1;i <= N;i++)
	{
		cin >> price[i];
		boong[i] = price[i];
	}
	//붕어빵을 팔 수 있는 셋트의 갯수가 일렬로 나열되어있는 상태.
	//최대한 팔 수 있는 방법을 얻기 위해선, 어떤 붕어빵 세트를 팔았을경우
	//붕어빵 판매목표갯수에서 차감한 후, 남아있는 붕어빵의 갯수 내에서 얻을 수 있는 최댓값을 구해낸다.
	//최종적으로 원하는 갯수의 붕어빵에 도달할 때 까지의 경우를 구한 후, 그 최대값을 얻어낸다.
	for (int i = 1;i <= N;i++)
	{
		for (int j = 1;j <= N;j++)
		{
			if (i + j <= N)
			{
				if (boong[i + j] <= boong[i] + price[j])
				{
					//붕어빵을 i개 판매한 상태에서 j개짜리 세트를 판매하는경우
					//그 때, 붕어빵을 i+j개 누적판매한 금액보다 새로이 최댓값이 될 경우엔 그 값으로 대체해준다.
					boong[i + j] = boong[i] + price[j];
				}
			}
		}
	}

	cout << boong[N] << endl;

	return 0;
}
