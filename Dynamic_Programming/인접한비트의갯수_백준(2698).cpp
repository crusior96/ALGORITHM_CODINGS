#include<iostream>
using namespace std;
int arr[102][102][2];		//arr[a][b][c] : 길이가 a인 비트순열들이 있을 때, 해당 비트의 인접 비트값이 b인 비트순열의 갯수
							//				 이때, 해당 비트 순열의 끝자리는 c이다


//비트 수열의 인접비트수를 구하는 방법은 인접한 비트끼리 서로 곱해서 더해보는 것이다
//이때, 길이가 N이고 인접비트수가 K인 비트 수열의 갯수들을 모두 구하여라

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);

	arr[1][0][1] = 1;
	arr[1][0][0] = 1;	//점화식을 사용하기 위한 초기값 지정. 최소한 길이가 1인 비트순열의 갯수는 1이기 때문.

	for (int i = 2;i <= 101;i++) {
		for (int j = 0;j < i;j++) {
			//점화식의 규칙
			//1. 비트순열의 길이가 i인데 인접 비트값이 j이고 끝자리가 0인 순열의 갯수
			//2. 비트순열의 길이가 i인데 인접 비트값이 j이고 끝자리가 1인 순열의 갯수
			//대부분 i-1에서의 인접 비트값이 j인 순열 갯수를 더하지만, 끝자리가 1인 순열의 갯수를 구할땐
			//i-1에서의 인저 비트값이 j-1인 순열의 갯수를 더하게 된다. 끝자리가 1이라 인접 비트값이 1 증가하기 때문
			arr[i][j][0] = arr[i - 1][j][0] + arr[i - 1][j][1];
			arr[i][j][1] = arr[i - 1][j][0] + arr[i - 1][j - 1][1];
		}
	}

	int Tc;
	cin >> Tc;
	for (int i = 0;i < Tc;i++) {
		long long int answer = 0;
		int N, K;
		cin >> N >> K;

		//비트 순열의 길이가 N이고 인접 비트값이 K인데 끝자리가 각각 0이거나 1인 값들을 더해준다
		answer = arr[N][K][0] + arr[N][K][1];
		cout << answer << '\n';
	}
	return 0;
}