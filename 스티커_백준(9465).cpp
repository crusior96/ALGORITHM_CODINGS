#include<iostream>
#include<algorithm>
using namespace std;

//스티커가 2행 S열로 배치되어있는 2N개의 스티커가 있다.
//각각의 스티커엔 점수가 있고, 점수의 합이 최대가 될 수 있도록 스티커들을 떼네려고 한다.
//단, 스티커를 떼게 되면, 그 스티커의 4방향 1칸 내에 있는 스티커들은 사용할 수 없게 된다.
//S는 0 이상 100000 이하의 정수이며, 각 스티커들의 점수는 0 이상 100 이하이다.

long long int sticker[100001][3] = {};  //스티커가 붙여지는걸 보여주는 배열
long long int checker[100001][3] = {};  //

int main()
{
	int N, S;
	cin >> N;
	for (int i = 0;i < N;i++)
	{
		cin >> S;
		for (int j = 0;j <= 1;j++)
		{
			for (int k = 1;k <= S;k++)
			{
				cin >> sticker[k][j];
			}
		}

		//초기 checker [0][0], [0][1], [0][2]의 초기값은 주어지지 않는다.
		//0개의 스티커를 뽑아내는 경우에는 누적되는 점수가 없기 때문.
		//무조건 많은 갯수의 스티커를 뽑는 행위가 최대값으로 이끌어주지 않는다.
		//대갓선 방향으로만 뽑는 것이 아닌, 경우에 따라서는 이번 행에선 스티커를 뽑지 않고 다음 행에서 스티커를 뽑는 행위도 고려해주어야한다.

		for (int j = 1;j <= S;j++)
		{
				checker[j][0] = max(max(checker[j - 1][0], checker[j - 1][1]), checker[j - 1][2]); 
				//이번 행의 스티커를 뽑는 행위를 안 하고 다음 행의 스티커를 뽑기위해 준비하는 코드.
				//이전 행에서 최대한 얻을 수 있는 점수를 저장해둔다.
				checker[j][1] = max(checker[j - 1][0], checker[j - 1][2]) + sticker[j][0];
				//이번 행의 스티커를 2번째 열에서 뽑는 코드.
				//이전 행에서 1번째 열에서 뽑았었거나, 안 뽑고 이번 행에서 뽑기로 하는 경우의 최댓값을 비교한 후, 이번 행의 0번째 열의 스티커 점수값을 추가해준다.
				checker[j][2] = max(checker[j - 1][0],checker[j - 1][1]) + sticker[j][1];
				//이번 행의 스티커를 1번째 열에서 뽑는 코드.
				//이전 행에서 2번째 열에서 뽑았었거나, 안 뽑고 이번 행에서 뽑기로 하는 경우의 최댓값을 비교한 후, 이번 행의 1번째 열의 스티커 점수값을 추가해준다.
		}

		cout << max(max(checker[S][0], checker[S][1]), checker[S][2])<<endl;
	}

	return 0;
}